# getoptlong.sh

**注意:** このマニュアルはAIによって生成されたものであり、不正確な情報を含んでいる可能性があります。注意して使用し、決定的な情報についてはソースコードやサンプルを参照してください。

`getoptlong.sh` は、シェルスクリプトでコマンドラインオプションを解析するためのBashライブラリです。以下を含むオプションを柔軟に処理する方法を提供します。

- 明確で表現力豊かなオプション構文
- 短いオプション（例：`-h`）と長いオプション（例：`--help`）の両方をサポート
- オプションと非オプション引数をコマンドラインで自由に混在させることができます (PERMUTE)
- フラグ型のインクリメンタルオプション、必須引数、オプション引数、配列型、ハッシュ型のオプションに対応
- 整数、浮動小数点数、カスタム正規表現パターンによるバリデーション機能
- 各オプションにコールバック関数を登録でき、柔軟な処理が可能
- 複数回の呼び出しをサポートし、サブコマンドで異なるオプションを使用したり、関数内で独自のオプション解析を行ったりできます
- ヘルプオプションとヘルプメッセージの自動生成。ヘルプオプションは明示的な定義なしで実装され、ヘルプメッセージはオプション定義から自動生成されます。

## 目次

- [1. はじめに](#1-はじめに)
- [2. 基本的な使い方](#2-基本的な使い方)
  - [2.1. シンプルなワンライナーでの使い方](#21-シンプルなワンライナーでの使い方)
  - [2.2. 標準的な複数ステップでの使い方](#22-標準的な複数ステップでの使い方)
    - [2.2.1. オプション定義配列の作成](#221-オプション定義配列の作成)
    - [2.2.2. ライブラリのソーシング](#222-ライブラリのソーシング)
    - [2.2.3. getoptlongの初期化](#223-getoptlongの初期化)
    - [2.2.4. コマンドライン引数の解析](#224-コマンドライン引数の解析)
    - [2.2.5. 解析結果の変数への設定](#225-解析結果の変数への設定)
    - [2.2.6. 変数へのアクセスと使用](#226-変数へのアクセスと使用)
- [3. 詳細なオプション定義](#3-詳細なオプション定義)
  - [3.1. 基本構文](#31-基本構文)
  - [3.2. オプションの型と型指定子](#32-オプションの型と型指定子)
    - [3.2.1. フラグオプション（接尾辞なしまたは `+`）](#321-フラグオプション接尾辞なしまたは-)
    - [3.2.2. 必須引数オプション (`:`)](#322-必須引数オプション--)
    - [3.2.3. オプション引数オプション (`?`)](#323-オプション引数オプション--)
    - [3.2.4. 配列オプション (`@`)](#324-配列オプション--)
    - [3.2.5. ハッシュオプション (`%`)](#325-ハッシュオプション--)
    - [3.2.6. コールバックオプション (`!`)](#326-コールバックオプション--)
  - [3.3. 格納先変数名の指定](#33-格納先変数名の指定)
  - [3.4. 値のバリデーション](#34-値のバリデーション)
    - [3.4.1. 整数バリデーション (`=i`)](#341-整数バリデーション-i)
    - [3.4.2. 浮動小数点数バリデーション (`=f`)](#342-浮動小数点数バリデーション-f)
    - [3.4.3. カスタム正規表現バリデーション (`=(<regex>)`](#343-カスタム正規表現バリデーション-regex)
- [4. ヘルプメッセージの生成とカスタマイズ](#4-ヘルプメッセージの生成とカスタマイズ)
  - [4.1. 自動ヘルプオプション](#41-自動ヘルプオプション)
  - [4.2. ヘルプメッセージの内容](#42-ヘルプメッセージの内容)
    - [4.2.1. オプションの説明（コメント `#`）](#421-オプションの説明コメント-)
    - [4.2.2. 型に基づく自動メッセージ](#422-型に基づく自動メッセージ)
    - [4.2.3. 初期値（デフォルト値）の表示](#423-初期値デフォルト値の表示)
    - [4.2.4. フラグオプションのカウンターとしての扱い](#424-フラグオプションのカウンターとしての扱い)
  - [4.3. ヘルプメッセージ全体のフォーマット](#43-ヘルプメッセージ全体のフォーマット)
    - [4.3.1. Synopsis（使い方）のカスタマイズ（`USAGE` 設定）](#431-synopsis使い方のカスタマイズusage-設定)
    - [4.3.2. `getoptlong help` による手動表示](#432-getoptlong-help-による手動表示)
  - [4.4. ヘルプメッセージの構造](#44-ヘルプメッセージの構造)
- [5. 高度なトピック](#5-高度なトピック)
  - [5.1. コールバック関数の詳細](#51-コールバック関数の詳細)
    - [5.1.1. 通常のコールバック（後処理）](#511-通常のコールバック後処理)
    - [5.1.2. 前処理コールバック (`--before` / `-b`)](#512-前処理コールバック---before---b)
    - [5.1.3. コールバック関数でのエラーハンドリング](#513-コールバック関数でのエラーハンドリング)
    - [5.1.4. コールバックを使用したカスタムバリデーション](#514-コールバックを使用したカスタムバリデーション)
  - [5.2. 格納先変数の指定](#52-格納先変数の指定)
  - [5.3. オプションのパススルー](#53-オプションのパススルー)
  - [5.4. 実行時の設定変更 (`getoptlong configure`)](#54-実行時の設定変更-getoptlong-configure)
  - [5.5. 内部状態のダンプ (`getoptlong dump`)](#55-内部状態のダンプ-getoptlong-dump)
- [6. コマンドリファレンス](#6-コマンドリファレンス)
  - [6.1. `getoptlong init <opts_array_name> [CONFIGURATIONS...]`](#61-getoptlong-init-opts_array_name-configurations)
  - [6.2. `getoptlong parse "$@"`](#62-getoptlong-parse--)
  - [6.3. `getoptlong set`](#63-getoptlong-set)
  - [6.4. `getoptlong callback [-b|--before] <opt_name> [callback_function] ...`](#64-getoptlong-callback--b---before-opt_name-callback_function--)
  - [6.5. `getoptlong configure <CONFIG_PARAM=VALUE> ...`](#65-getoptlong-configure-config_paramvalue--)
  - [6.6. `getoptlong dump [-a|--all]`](#66-getoptlong-dump--a---all)
  - [6.7. `getoptlong help <SYNOPSIS>`](#67-getoptlong-help-synopsis)
- [7. 実用的な例](#7-実用的な例)
  - [7.1. 必須オプションとオプション引数の組み合わせ](#71-必須オプションとオプション引数の組み合わせ)
  - [7.2. サブコマンドを持つスクリプト（簡易版）](#72-サブコマンドを持つスクリプト簡易版)
  - [7.3. `ex/` ディレクトリのサンプルスクリプト](#73-ex-ディレクトリのサンプルスクリプト)
- [8. 設定キー](#8-設定キー)
- [9. 関連項目](#9-関連項目)

## 1. はじめに

`getoptlong.sh` は、シェルスクリプト内でコマンドラインオプションを解析するために設計されたBashライブラリです。組み込みの `getopts` コマンドに代わる堅牢で柔軟な代替手段を提供し、GNUスタイルのロングオプション、オプションの順列、様々な引数タイプ（必須、オプション、配列、ハッシュ）、データバリデーション、コールバックメカニズム、そしてヘルプメッセージの自動生成をサポートします。その目標は、Bashにおいて複雑になりがちなコマンドライン引数処理を簡素化し、スクリプトをよりユーザーフレンドリーで保守しやすくすることです。

## 2. 基本的な使い方

`getoptlong.sh` は、スクリプトにオプション解析を統合するための主要な2つの方法を提供します：シンプルなワンライナーアプローチと、標準的な複数ステップアプローチです。

### 2.1. シンプルなワンライナーでの使い方

多くの一般的なユースケースでは、`getoptlong.sh` はライブラリをソースし、オプションを定義し、引数を解析し、変数を設定する一行で呼び出すことができます。これは最も手軽に始める方法です。

**手順:**

1.  **オプション配列を定義する:** オプション定義を格納するBashの連想配列（例：`OPTS`）を作成します。

2.  **ソースして実行する:** `.` (source) コマンドに続けて `getoptlong.sh`、オプション配列の名前、そして `"$@"` を指定します。

**例:**

```bash
#!/usr/bin/env bash

# 1. オプション配列を定義する

declare -A OPTS=(
    [ trace     | x  ]=  # シンプルなフラグ。存在すれば 'trace' 変数を1に設定
    [ debug     | d  ]=0 # シンプルなフラグ。初期値は '0'
    [ count     | c: ]=1 # 必須引数を取るオプション。'count' 変数を設定
)

# 2. getoptlong.sh をソースし、OPTS配列とスクリプト引数を渡す

. getoptlong.sh OPTS "$@"

# 3. 解析されたオプションを使用する

(( debug > 0 )) && echo "デバッグモードが有効です"

# 4. 非オプション引数を処理する

echo "$@"
```

**仕組み:**

`getoptlong.sh` がオプション配列名と引数と共にソースされると (`. getoptlong.sh OPTS "$@"`), 内部で以下の処理を実行します:

*   自身をソースし、その関数を利用可能にする。
*   提供された `OPTS` 配列を使用して初期化する。
*   `"$@"` 引数を解析する。
*   対応するシェル変数を設定し、位置パラメータを更新する。

このアプローチは簡潔で、多くのスクリプトにとって十分です。もし解析プロセスをより細かく制御する必要がある場合（例えば、解析後のカスタムエラーハンドリングや、サブコマンド用に異なるオプションで再初期化するなど）、次に説明する標準的な複数ステップでの使い方がより適しています。

### 2.2. 標準的な複数ステップでの使い方

この方法は、プロセスを個別のステップに分解し、より高い柔軟性を提供します。

#### 2.2.1. オプション定義配列の作成

まず、スクリプトが受け付けるオプションをBashの連想配列として定義します。配列名は任意です。各オプションキーのフォーマットと利用可能な型については、「3. 詳細なオプション定義」を参照してください。

```bash
declare -A OPTS=(
    [verbose |v+ # 冗長度を上げる（累積）                 ]=0
    [output  |o: # 出力ファイルを指定                     ]=/dev/stdout
    [config  |c? # 設定ファイルを指定（任意）             ]=
    [library |L@ # ライブラリパスを追加                   ]=()
    [define  |D% # 変数を定義（例：key=val）              ]=()
)
```

**注意:** ヘルプオプション（デフォルトは `--help`, `-h`）は自動的に利用可能です。その動作とカスタマイズについては、「4. ヘルプメッセージの生成とカスタマイズ」を参照してください。必要であれば、上記の例のように明示的に定義できます。

#### 2.2.2. ライブラリのソーシング

次に、スクリプト内から `source` コマンド（または `.` コマンド）を使って `getoptlong.sh` ファイルをソースします。これにより、`getoptlong` 関数とそのサブコマンドが利用可能になります。

```bash
. $(dirname $0)/getoptlong.sh # getoptlong.sh への実際のパスに置き換えてください
# または、getoptlong.sh が実行パスにある場合:
# . getoptlong.sh
```

#### 2.2.3. getoptlongの初期化

定義したオプション配列を `getoptlong init` コマンドに渡し、ライブラリを初期化します。

```bash
getoptlong init OPTS
```

初期化中に、オプション解析の振る舞いを制御する様々な設定パラメータを指定できます。詳細は「6.1. `getoptlong init ...`」を参照してください。

例：非オプション引数を `ARGS` 配列に格納し、解析エラー時にスクリプトが終了しないようにする。

```bash
declare -a ARGS # PERMUTEで指定する配列は事前に宣言しておくのが良い習慣です
getoptlong init OPTS PERMUTE=ARGS EXIT_ON_ERROR=0
```

#### 2.2.4. コマンドライン引数の解析

すべてのスクリプト引数 (`"$@"`) を `getoptlong parse` コマンドに渡し、定義に基づいて解析させます。

```bash
if ! getoptlong parse "$@"; then
    # 解析エラーを処理する (EXIT_ON_ERROR=0 の場合)
    echo "引数の解析に失敗しました。" >&2
    getoptlong help "Usage: $(basename "$0") [options] arguments..." # エラー時にヘルプを表示
    exit 1
fi
```

`getoptlong parse` は、解析が成功した場合は終了コード `0` を、失敗した場合は非ゼロを返します。`EXIT_ON_ERROR` が `1`（デフォルト）の場合、スクリプトは解析エラー時に自動的に終了します。

#### 2.2.5. 位置パラメータの設定

`getoptlong parse` がコマンドライン引数を正常に処理した後、オプションのシェル変数は解析中に自動的に設定されます。`getoptlong set` コマンドは `eval` と共に使用され、位置パラメータのみを更新します。

```bash
eval "$(getoptlong set)"
```

これにより、スクリプトの位置パラメータ（`$1`, `$2` など）が、解析プロセスによって決定された残りの非オプション引数に再設定されます（`PERMUTE` の動作が設定されている場合は、その設定に従います）。例えば、`myscript --opt val arg1 arg2` が呼び出された場合、`eval "$(getoptlong set)"` の後では `$1` は `arg1` に、`$2` は `arg2` になります。

#### 2.2.6. 変数へのアクセスと使用

オプション変数は `getoptlong parse` 中に自動的に設定されます。スクリプト内でこれらの変数を使用して、オプションに基づいたアクションを実行します。

*   **変数割り当ての詳細:**
    *   フラグオプション（例：`[verbose|v]`）は、最初の使用で変数を `1` に設定し、その後の使用でインクリメントします。
    *   配列オプション（例：`[library|L@]`）は、Bash配列（例：`"${library[@]}"`）に格納されます。
    *   ハッシュオプション（例：`[define|D%]`）は、Bashの連想配列に格納されます。
    *   デフォルトのオプション変数名に含まれるハイフン (`-`) はアンダースコア (`_`) に変換されます（例：`--long-option` は `$long_option` となります）。

```bash
# ヘルプオプションが処理された場合（自動または手動で）、
# スクリプトは通常 'getoptlong parse' または 'getoptlong set' 中に終了しますが、
# 明示的にチェックすることも可能です（例：カスタムヘルプ処理のため）。
if [[ -n "${help:-}" ]]; then
    # ('getoptlong help' が呼び出された場合は通常到達しない)
    # カスタムヘルプ表示処理など
    exit 0
fi

echo "冗長出力レベル: ${verbose:-0}" # 設定されていない場合は0を表示

if [[ "$output" != "/dev/stdout" ]]; then
    echo "出力先: $output"
fi

if [[ -n "${config:-}" ]]; then # configが空文字列または未設定でないかチェック
    echo "設定ファイルをロード中: $config..."
    # source "$config" など、設定ファイルを読み込む処理
elif [[ -v config ]]; then # configオプションが指定されたが値がない場合（空文字列に設定）
    echo "設定ファイルが指定されましたが、パスがありません。"
else
    echo "デフォルト設定を使用します。"
fi

if (( ${#library[@]} > 0 )); then
    echo "ライブラリパス:"
    for libpath in "${library[@]}"; do
        echo "  - $libpath"
    done
fi

if (( ${#define[@]} > 0 )); then
    echo "定義された変数:"
    for key in "${!define[@]}"; do
        echo "  - $key = ${define[$key]}"
    done
fi

# 非オプション引数は `eval "$(getoptlong set)"` の後、
# 位置パラメータ ($1, $2, など) として利用可能です。
# `getoptlong init` 中に PERMUTE=<array_name> が使用された場合（または OPTS 内の &PERMUTE）、
# それらの非オプション引数は指定された配列でも利用可能です。
if (( $# > 0 )); then
    echo "残りの引数 ($#):"
    for arg in "$@"; do # 位置パラメータをループ
        echo "  - $arg"
    done
fi
```

## 3. 詳細なオプション定義

`getoptlong.sh` のコマンドラインオプションは、Bashの連想配列を使用して定義されます。このセクションでは、詳細な定義方法と利用可能なオプションの型について説明します。

### 3.1. 基本構文

オプションは連想配列のキーとして定義されます。キー文字列は以下のフォーマットを取ります:

`名前[|エイリアス...][<型>[<修飾子>]][格納先][=<バリデーション>] # 説明`

このキーに対応する連想配列の値は、オプションの初期値を指定します。キー文字列内の `#` 以降はコメントとして扱われ、自動生成されるヘルプメッセージの説明として使用されます。

例:

```bash
declare -A OPTS=(
    # 名前         エイリアス
    # |            | 型 [:?@%]
    # |            | |修飾子 [!>]
    # |            | ||バリデーション
    # |            | |||      説明                           初期値
    # |            | |||      |                              |
    [ verbose    | v          # 詳細情報を出力                ]=
    [ output     | o :        # 出力ファイルを指定            ]=/dev/stdout
    [ mode       | m ?        # 動作モード（任意）            ]=
    [ include    | i @        # インクルードパス（複数可）    ]=()
    [ define     | D %        # 定義 (キー=値)                ]=()
    [ execute    | x  !       # コマンドを実行                ]=my_execute_function
    [ count      | N : =i     # 繰り返し回数（整数）          ]=1
    [ ratio      | r : =f     # 比率（浮動小数点数）          ]=0.5
    [ id         | K : =(^[a-z0-9_]+$) # ID (英数字と_)      ]=default_id
)
```

*   **`名前`:** (必須) `--` に続くロングオプション名（例：`verbose`）。ハイフンを含むことができます（例：`very-verbose`）。これは、オプションの値が格納される変数のデフォルトのベース名にもなります（ハイフンはアンダースコアに置換されます）。ただし、`格納先変数`が指定されている場合を除きます（セクション3.3参照）。

*   **`エイリアス`:** (任意) `-` に続く1つ以上のオプションエイリアス（例：`v`）。複数のエイリアスは `|` で区切って指定できます（例：`long|s|t`）。短い名前のみが定義された場合（例：`[s:]`）、`格納先変数`が指定されていない限り、それが変数名のベースになります（セクション3.3参照）。

*   **`型` (型指定子):** (任意) オプションが引数をどのように扱うかを指定する1文字。省略された場合、デフォルトは `+`（フラグ/カウンター型）になります。指定可能な値は:
    *   `+`: フラグオプション。振る舞いはセクション3.2.1を参照。
    *   `:`: オプションは引数を必須とします。
    *   `?`: オプションは任意の引数を取ります。
    *   `@`: オプションは複数回指定でき、値は配列に格納されます。
    *   `%`: オプションは `キー=値` のペアを取り、連想配列に格納されます。

*   **`修飾子`:** (任意) オプションの振る舞いを変更する特殊文字で、`型`（もしあれば）の直後に続きます:

    *   `!`: コールバック。このオプションが解析されると、指定された関数（またはオプション名や`格納先`に基づくデフォルトの関数）が呼び出されます。格納先変数を指定する場合はセクション3.3を参照してください。

    *   `>`: パススルー。オプションとその引数（もしあれば）が指定された配列に収集されます。これは`型`の後に続く必要があります。「5.3. オプションのパススルー」セクションを参照してください。

    これらは組み合わせることができます（例：`!>`）。

*   **`格納先`:** (任意) オプションの値を格納するカスタム変数名を指定します。この名前は`型文字`と任意の`修飾子`の直後に現れます。詳細と例については「3.3. 格納先変数名の指定」セクションを参照してください。

*   **`=<バリデーション>`:** (任意) 引数の値に対するバリデーションを指定します。これは、`格納先`が存在する場合はその後に、それ以外の場合は`型`/`修飾子`の後に続きます。詳細は「3.4. 値のバリデーション」セクションを参照してください。例：`=i`（整数）、`=f`（浮動小数点数）、`=(<regex>)`。

*   **`# 説明`:** `#` に続くテキストは、ヘルプメッセージでオプションの説明として使用されます。

*   **初期値:** 連想配列の要素の値として指定されます。これは、コマンドラインでオプションが提供されなかった場合のデフォルト値になります。指定されない場合の振る舞いは型によって異なります（例：フラグは空文字列、配列は空配列がデフォルト）。

`getoptlong parse` で解析し、`eval "$(getoptlong set)"` で変数を設定した後、オプションに対応するシェル変数（デフォルト名またはカスタムの`格納先`名）が設定されます。`PREFIX` 設定は、これらの変数名に共通のプレフィックスを追加できます。`名前`に含まれるハイフン (`-`) は、デフォルトの変数名ではアンダースコア (`_`) に変換されます（例：`--very-verbose` は `$very_verbose` または `$PREFIX_very_verbose` になります）。

### 3.2. オプションの型と型指定子

#### 3.2.1. フラグオプション（接尾辞なしまたは `+`）

引数を取らないスイッチとして機能し、単純なフラグとカウンターの両方として使用できます。他の型指定子が提供されない場合、`+` 型指定子がデフォルトです。

*   **定義例:**
    *   `[verbose|v  # 詳細出力 ]=` (`[verbose|v+]` と同等)
    *   `[debug|d+   # デバッグレベル    ]=0` (変数参照を容易にするための初期値)
    *   `[feature|f  # 機能を有効化 ]=`

*   **指定方法:** `-v`, `--verbose`, `--debug`, `-d`, `--feature`

*   **変数の振る舞い:**
    *   最初の指定: 変数は `1` に設定されます。
    *   複数回の指定 (例: `-vvv` や `--debug --debug`): 変数の値がインクリメントされます。
    *   `no-` プレフィックス付きでの指定 (例: `--no-debug`): 変数は空文字列にリセットされます。

*   **ユースケース:** 真偽値フラグ、冗長度レベル、デバッグレベル。数値の初期値（例：`]=0`）を設定すると、`(( debug > 0 ))` のような算術コンテキストでの変数参照が簡単になります。

#### 3.2.2. 必須引数オプション (`:`)

常に値を必要とするオプション。

*   **定義例:** `[output|o: # 出力ファイル]`

*   **値の指定方法:**
    *   ロングオプション: `--output=value`, `--output value`
    *   ショートオプション: `-ovalue`, `-o value`
    *   注意: `-o=value` の形式はショートオプションではサポートされていません。

*   **変数への格納:** 指定された値は文字列として変数に格納されます（例：`$output`）。

*   **初期値:** 指定されない場合はエラーになりますが、定義時に初期値を設定できます（例：`]=/dev/stdout`）。

*   **ユースケース:** ファイルパスの指定、必須パラメータ。

#### 3.2.3. オプション引数オプション (`?`)

値を取ることも、値なしで指定することもできるオプション。

*   **定義例:** `[mode|m? # 動作モード]`

*   **値の指定方法:**
    *   ロングオプション:
        *   `--mode=value`: 変数 `$mode` は `value` に設定されます。
        *   `--mode`: 変数 `$mode` は空文字列 `""` に設定されます。
    *   ショートオプション:
        *   `-m`: 変数 `$mode` は空文字列 `""` に設定されます。
        *   注意: `-mvalue` のように値を直接連結する形式はショートオプションではサポートされていません。値を指定する必要がある場合はロングオプションを使用してください。

*   **変数への格納:**
    *   値が指定された場合: その値が変数に格納されます。
    *   オプションが値なしで指定された場合: 空文字列 `""` が変数に格納されます。
    *   オプションが指定されなかった場合: 変数は未設定のままです（初期値が定義されていない場合）。存在は `${variable+_}` や `[[ -v variable ]]` で確認できます。

*   **初期値:** 定義時に設定できます（例：`]=default_mode`）。

*   **ユースケース:** オプションの設定値、特定の場合にのみ有効なパラメータ。

#### 3.2.4. 配列オプション (`@`)

複数の値を配列として受け付けます。

*   **定義例:** `[include|I@ # インクルードパス]`

*   **値の指定方法:**
    *   オプションを複数回指定する: `--include /path/a --include /path/b`, `-I /path/a -I /path/b`
    *   1つのオプションで複数の値を指定する（`DELIM` 設定で制御される区切り文字。デフォルトはカンマ、スペース、タブ）:
        *   `--include /path/a,/path/b`
        *   `--include "/path/a /path/b"`
        *   `-I /path/a,/path/b`

*   **変数への格納:** 指定された値はBash配列に格納されます（例：`"${include[@]}"`）。

*   **初期値:** 通常は空の配列。定義時に初期値を設定できます（例：`]=(/default/path1 /default/path2)`）。

*   **ユースケース:** 複数の入力ファイル、複数の設定項目。

#### 3.2.5. ハッシュオプション (`%`)

`キー=値` のペアを連想配列（ハッシュ）として受け付けます。

*   **定義例:** `[define|D% # マクロ定義 (例: KEY=VALUE)]`

*   **値の指定方法:**
    *   オプションを複数回指定する: `--define OS=Linux --define VER=1.0`, `-D OS=Linux -D VER=1.0`
    *   1つのオプションで複数のペアを指定する（`DELIM` 設定で制御される区切り文字。デフォルトはカンマ）:
        *   `--define OS=Linux,VER=1.0`
        *   `-D OS=Linux,VER=1.0`
    *   値（`=VALUE`）が省略された場合、`=1` が指定されたものとして扱われます（例：`--define DEBUG` は `DEBUG=1` と解釈されます）。

*   **変数への格納:** 指定されたキーと値はBashの連想配列に格納されます（例：`declare -A define_map="${define[@]}"; echo "${define_map[OS]}"`）。

*   **初期値:** 通常は空の連想配列。定義時に初期値を設定できます（例：`]=([USER]=$(whoami))`）。

*   **ユースケース:** 環境変数のような設定、キーと値のペアとして管理される情報。

#### 3.2.6. コールバックオプション (`!`)

オプションが解析されると、指定されたコールバック関数が呼び出されます。この `!` 指定子は、上記のいずれのオプションタイプ（`+`, `:`, `?`, `@`, `%`）にも追加できます。

*   **定義例:**
    *   `[execute|x! # コマンドを実行]` (フラグ型コールバック)
    *   `[config|c:! # 設定ファイルをロード]` (必須引数型コールバック)

*   **振る舞い:**
    *   コマンドラインでオプションが指定されると、関連付けられたコールバック関数が実行されます。
    *   デフォルトでは、コールバック関数名はオプションのロングネームと同じです（ハイフンはアンダースコアに変換されます）。`getoptlong callback` コマンドを使用して、任意の関数名を指定できます。
    *   コールバック関数の呼び出しタイミングと引数については、「6.4. `getoptlong callback ...`」と「5.1. コールバック関数の詳細」を参照してください。

*   **ユースケース:** オプション解析中のカスタムアクションの実行、複雑な値の処理、即時の設定変更。

### 3.3. 格納先変数名の指定

デフォルトでは、`getoptlong.sh` は解析されたオプション（例：`--my-option value`）の値を、オプションのロングネームから派生したシェル変数（例：`$my_option`、ハイフンはアンダースコアに置換）に格納します。しかし、オプションの定義文字列内で、その値のカスタム変数名を直接指定することができます。

これは、オプションの型指定子（例：`+`, `:`, `?`, `@`, `%`）と任意の修飾子（例：`!`, `-`）の直後に、希望の変数名を書くことで実現されます。

*   **オプション定義における構文:** 完全な構造については、「3.1. 基本構文」を再度参照してください: `ロングネーム[|ショートネーム...][<型文字>[<修飾子>]][格納先変数名][=<バリデーションタイプ>] # 説明`。`格納先変数名`がカスタム変数名です。

*   **`ex/dest.sh` からの例:**
    スクリプト `ex/dest.sh` はこの機能を示しています:
    ```bash
    declare -A OPTS=(
        [ count     | c :COUNT=i # 繰り返し回数              ]=1
        [ sleep     | i @SLEEP=f # インターバル時間            ]=
        [ paragraph | p ?PARA    # サイクル後に改行を出力      ]=
        [ trace     | x !TRACE   # 実行をトレース            ]= # TRACEはコールバックコンテキストの変数名になる
        [ debug     | d +DEBUG   # デバッグレベル              ]=0
        [ message   | m %MSG=(^(BEGIN|END|EACH)=) # BEGIN|END|EACHでメッセージを出力 ]=
    )
    ```
    この例では:
    *   `[count|c:COUNT=i]`: `--count` の値を `COUNT` に格納します（整数としてバリデーション）。
    *   `[sleep|i@SLEEP=f]`: `--sleep` の値を配列 `SLEEP` に格納します（浮動小数点数としてバリデーション）。
    *   `[paragraph|p?PARA]`: `--paragraph` のオプショナル引数を `PARA` に格納します。
    *   `[debug|d+DEBUG]`: `--debug` のインクリメント値を `DEBUG` に格納します。
    *   `[message|m%MSG=(...)]`: `--message` からのキーと値のペアを連想配列 `MSG` に格納します。

*   **振る舞い:**
    *   `getoptlong parse "$@"` と `eval "$(getoptlong set)"` の後、指定された変数（例では `COUNT`, `SLEEP`, `PARA`, `DEBUG`, `MSG`）に解析された値が含まれます。
    *   このオプションごとの格納先変数の指定は、`ロングネーム`や`ショートネーム`に基づくデフォルトの変数命名規則を上書きします。
    *   `PREFIX` 設定（「6.1. `getoptlong init ...`」参照）も、これらのカスタム変数名に適用されます。例えば、`PREFIX=MY_` でオプションが `[opt:VAR]` の場合、値は `$MY_VAR` に格納されます。

*   **ユースケース:**
    *   より説明的または慣習的な変数名を使用する（例：グローバル設定のための `ALL_CAPS`）。
    *   他の変数や関数との名前の衝突を避ける。
    *   オプションの値がどこに格納されるかを明示的に示すことで、コードの可読性を向上させる。

### 3.4. 値のバリデーション

オプションに渡される引数の値を検証する機能があります。バリデーションは、オプション定義の末尾に `=<バリデーションタイプ>` を追加することで指定します。

#### 3.4.1. 整数バリデーション (`=i`)

引数が整数であるかを検証します。

*   **定義例:** `[count|c:COUNT=i # 繰り返し回数]` (COUNTが格納先変数の場合) または `[count|c:=i # 繰り返し回数]` (デフォルトの変数名を使用する場合)。

*   **振る舞い:** 引数が整数でない場合、エラーメッセージが表示され、スクリプトは終了します（デフォルトの振る舞い、`EXIT_ON_ERROR=1` の場合）。

*   配列オプション (`@...=i`) やハッシュオプションの値部分 (`%...=i`) に適用可能です。

#### 3.4.2. 浮動小数点数バリデーション (`=f`)

引数が浮動小数点数であるかを検証します。

*   **定義例:** `[ratio|r:RATIO=f # 比率]` または `[ratio|r:=f # 比率]`

*   **振る舞い:** 引数が浮動小数点数でない場合（例：`123.45` はOK、`1.2e-3` はサポートされない場合があります）、エラーメッセージが表示され、スクリプトは終了します。

*   配列オプション (`@...=f`) やハッシュオプションの値部分 (`%...=f`) に適用可能です。

#### 3.4.3. カスタム正規表現バリデーション (`=(<regex>)`)

引数が指定されたBash拡張正規表現（ERE）に一致するかを検証します。正規表現は `=` の直後の `(` から対応する最後の `)` までです。

*   **定義例:**
    *   `[mode|m:=(^(fast|slow|debug)$)]` (fast, slow, debug のいずれか)
    *   `[name|N@=(^[A-Za-z_]+$)]` (各要素が英字とアンダースコアのみを含む)
    *   `[param|P%:=(^[a-z_]+=[0-9]+$)]` (キーは小文字と_、値は数字)

*   **振る舞い:** 引数が正規表現に一致しない場合、エラーメッセージが表示され、スクリプトは終了します。

*   配列およびハッシュオプションに適用可能です。配列の場合、各要素が検証されます。ハッシュの場合、`キー=値` のペア全体が正規表現に対して検証されます。

## 4. ヘルプメッセージの生成とカスタマイズ

`getoptlong.sh` は、ユーザーにスクリプトの使い方を示すヘルプメッセージを自動的に生成する強力な機能を提供します。これにより、開発者が手動でヘルプテキストを管理する手間が大幅に削減されます。生成されるヘルプメッセージは、オプションをロングネーム（またはロングネームがなければショートネーム）のアルファベット順に表示します。

### 4.1. 自動ヘルプオプション

`getoptlong.sh` は、呼び出されると生成されたヘルプメッセージを表示してスクリプトを終了するヘルプオプションを自動的に提供します。

*   **デフォルトの振る舞い:**

    *   デフォルトでは、`--help` と `-h` がヘルプオプションとして認識されます。
    *   `OPTS` 配列で定義されていない場合、`getoptlong.sh` は暗黙的に `help|h#show help` を追加します。
    *   解析されると、ヘルプメッセージが表示され、スクリプトはステータス0で終了します。

*   **カスタマイズ:** この自動ヘルプオプションの名前、エイリアス、説明は以下を使用して変更できます:

    1.  **`OPTS` 配列内の `&HELP` キー (最高優先度):**

        ```bash
        declare -A OPTS=(
            [&HELP]="show-usage|u#使用情報を表示して終了します。"
            # ... 他のオプション定義 ...
        )
        getoptlong init OPTS
        ```

        これで、`--show-usage` または `-u` がヘルプメッセージをトリガーします。

    2.  **`getoptlong init` の `HELP` パラメータ (低優先度):**

        ```bash
        getoptlong init OPTS HELP="manual|m#完全なマニュアルを表示します。"
        ```

        `OPTS` に `&HELP` が設定されていない場合、`--manual` または `-m` がヘルプをトリガーします。

    *   `&HELP` も `HELP` も指定されていない場合、デフォルトの `help|h#show help` が使用されます。
    *   `OPTS` 内で同じ名前のオプションを明示的に定義する（例：`[help|h #... ]=`）ことも、`&HELP` のように機能し、デフォルトを上書きします。

*   **自動ヘルプの無効化:** 自動ヘルプオプションを完全に無効にするには、`HELP` を空文字列に設定し、`&HELP` キーや競合するオプション定義が存在しないことを確認します:

    ```bash
    getoptlong init OPTS HELP=""
    ```

### 4.2. ヘルプメッセージの内容

#### 4.2.1. オプションの説明（コメント `#`）

ヘルプメッセージに表示される各オプションの説明は、オプション定義配列内の各オプション定義のキー文字列の末尾にある `#` の後に記述します。

```bash
declare -A OPTS=(
    [output|o:   # 出力ファイルパスを指定します。 ]=/dev/stdout
    [verbose|v+  # 詳細なログを有効にします（複数指定でレベル増加）。 ]=0
)
```

上記のように定義すると、ヘルプメッセージは次のように表示されます（順序はオプション名によるソートに依存します）:

```
  -o, --output <value>     出力ファイルパスを指定します。 (default: /dev/stdout)
  -v, --verbose            詳細なログを有効にします（複数指定でレベル増加）。 (default: 0)
```

#### 4.2.2. 型に基づく自動メッセージ

オプション定義で `#` を介して説明が提供されない場合、`getoptlong.sh` はオプションの型情報（引数を取るか、引数の型など）に基づいて基本的な説明を自動生成します。

例:

*   `[input|i:]` (説明なし) → `  -i, --input <value>        引数が必要です。`

*   `[force|f]` (説明なし) → `  -f, --force                フラグオプションです。`

長く説明的なロングオプション名（例：`--backup-location`）を使用すると、自動生成されるメッセージの可読性が向上します。

#### 4.2.3. 初期値（デフォルト値）の表示

オプション定義時に初期値が指定されている場合（例：`[count|c:=i]=1`）、そのデフォルト値はヘルプメッセージに `(default: <value>)` のように表示されます。

```bash
declare -A OPTS=(
    [mode|m?     # 動作モードを指定 (fast, normal, slow) ]=normal
    [retries|r:=i # 最大リトライ回数 ]=3
)
```

ヘルプメッセージの表示例:

```
  -m, --mode [<value>]     動作モードを指定 (fast, normal, slow) (default: normal)
  -r, --retries <value>    最大リトライ回数 (default: 3)
```

#### 4.2.4. フラグオプションのカウンターとしての扱い

フラグオプション（型接尾辞なし、または `+`）に数値の初期値が指定されている場合（例：`[debug|d+]=0`）、そのオプションはカウンターとして扱われます。ヘルプメッセージにもこの初期値が表示されます。

### 4.3. ヘルプメッセージ全体のフォーマット

#### 4.3.1. Synopsis（使い方）のカスタマイズ（`USAGE` 設定）

ヘルプメッセージの冒頭に表示される使い方（Synopsis）の行（例：「Usage: myscript [options] <file>」）はカスタマイズできます。

*   **カスタマイズ方法:**

    1.  **`OPTS` 配列内の `&USAGE` キー (最高優先度):**

        ```bash
        declare -A OPTS=(
            [&USAGE]="Usage: $(basename "$0") [OPTIONS] SOURCE_FILE DEST_FILE"
            # ... 他のオプション定義 ...
        )
        getoptlong init OPTS
        ```

    2.  **`getoptlong init` の `USAGE` パラメータ (低優先度):**

        ```bash
        getoptlong init OPTS USAGE="正しい使い方: myscript -i <input> -o <output> [options]"
        ```

    *   `&USAGE`（`OPTS`内）も `USAGE`（`init`内）も指定されていない場合、ヘルプが自動的にトリガーされたときには、デフォルトでは使い方（Synopsis）の行は表示されません。ただし、下記の `getoptlong help` を参照してください。

*   **`getoptlong help` による動的なSynopsis:**
    `getoptlong help` コマンドは、動的にSynopsisを提供できます（次のセクションを参照）。

#### 4.3.2. `getoptlong help [SYNOPSIS_ARGUMENT]` による手動表示

スクリプト内のどこからでも `getoptlong help` コマンドを使用してヘルプメッセージを手動で表示できます。これは、特定のエラー時にヘルプを表示したり、自動メカニズムで処理されないカスタムヘルプフラグを介して表示したりするのに便利です。

*   **コマンド:** `getoptlong help [SYNOPSIS_ARGUMENT]`

*   **振る舞い:**

    *   現在のオプション定義と設定に基づいて、フォーマットされたヘルプメッセージを表示します。

    *   **`[SYNOPSIS_ARGUMENT]`:** (任意) 指定された場合、この文字列がこの特定のヘルプメッセージ呼び出しの使い方の行として使用されます。これは、`&USAGE` や `USAGE` の設定よりも優先されます。

        ```bash
        if [[ "$some_error_condition" == "true" ]]; then
            getoptlong help "エラー: 不正な入力です。 Usage: $(basename "$0") --input <file>" >&2
            exit 1
        fi
        ```

    *   `getoptlong help` に `[SYNOPSIS_ARGUMENT]` が提供され*なかった*場合:

        *   `&USAGE`（`OPTS`内）または `USAGE`（`init`内）で定義されたSynopsisが使用されます。
        *   どちらも設定されていない場合、使い方の行は表示されず、オプションリストのみが表示されます。

    *   自動ヘルプオプション（例：`--help`）は、内部的に `getoptlong help` を `SYNOPSIS_ARGUMENT` なしで呼び出すため、Synopsisの表示には `&USAGE` または `USAGE` に依存します。

### 4.4. ヘルプメッセージの構造

生成されるヘルプメッセージは、一般的に以下の構造を持っています:

1.  **使い方の行 (Synopsis):** （`USAGE` 設定または `getoptlong help` 引数で指定された場合）

2.  **オプションリスト:**

    *   各オプションは、ショートオプション（もしあれば）、ロングオプション（もしあれば）、引数プレースホルダー（例：`<value>`）、および説明と共に表示されます。

    *   オプションはロングネームのアルファベット順にソートされます。ロングネームがない場合は、ショートネームでソートされます。

    *   説明には初期値（`(default: ...)`）が含まれることがあります。

```
(使い方の行, 例: Usage: myscript [options] <file>)

Options:
  -h, --help                 このヘルプメッセージを表示して終了します。
  -f, --file <path>          入力ファイルを指定します。 (default: input.txt)
      --force                確認なしで操作を強制します。
  -n, --count <number>       操作回数。 (integer, default: 1)
  -v, --verbose              詳細な出力を有効にします。 (counter, default: 0)
      --version              バージョン情報を表示します。
```

（上記はヘルプメッセージの一般的な例です。実際の表示はオプション定義と設定によって異なります。）

## 5. 高度なトピック

このセクションでは、`getoptlong.sh` のより高度な使用法と便利な機能について説明します。

### 5.1. コールバック関数の詳細

コールバック関数を使用すると、特定のオプションが解析されたときに関数の実行が可能になります。これにより、単純な値の設定を超えた複雑な処理をオプション解析に統合できます。コールバック関数は、オプション定義に `!` 接尾辞を追加するか、`getoptlong callback` コマンドを使用して登録されます。

#### 5.1.1. 通常のコールバック（後処理）

デフォルトでは、コールバック関数はオプションの値が内部的に設定された**後**に呼び出されます。

*   **呼び出し形式:** `callback_function "option_name" "option_value" [registered_arg1 registered_arg2 ...]`

    *   `$1`: オプションのロングネーム（例：`my-option`）。

    *   `$2`: 解析されたオプションの値。フラグの場合は `1`（`no-` 付きで指定された場合は空文字列）。引数を取るオプションの場合は引数の値。配列やハッシュの場合は、最後に解析された要素またはペア。

    *   `$3...`: `getoptlong callback <opt_name> <func_name> arg1 arg2...` で登録時追加の引数が指定された場合、それらがここに渡されます。

*   **例:**

    ```bash
    declare -A OPTS=(
        [process-item|p:! # アイテムを処理]=
    )

    process_item_callback() {
        local opt_name="$1"
        local item_id="$2"
        echo "コールバック: オプション '$opt_name' が値 '$item_id' で指定されました。"
        # ここで item_id を使って処理を実行
        if [[ ! -f "$item_id" ]]; then
            echo "エラー: ファイル '$item_id' が見つかりません。" >&2
            # exit 1 # 必要に応じてエラーで終了
        fi
    }
    # getoptlong callback process-item process_item_callback # デフォルトで登録されるが、明示的にも可能
    # getoptlong callback process-item process_item_callback "追加の引数1" # 追加引数も渡せる

    getoptlong init OPTS
    getoptlong parse "$@" && eval "$(getoptlong set)"
    ```

#### 5.1.2. 前処理コールバック (`--before` / `-b`)

`getoptlong callback` コマンドで `--before`（または `-b`）オプションを指定することで、コールバック関数をオプションの値が内部的に設定される**前**に呼び出すことができます。

*   **呼び出し形式:** `callback_function "option_name" [registered_arg1 registered_arg2 ...]`

    *   `$1`: オプションのロングネーム。

    *   `$2...`: `getoptlong callback -b <opt_name> <func_name> arg1 arg2...` で登録時追加の引数が指定された場合、それらがここに渡されます。

    *   **注意:** オプションの値は前処理コールバックには渡されません。これらは値の処理を目的とするものではなく、値が設定される前の状態変更や準備に適しています。

*   **ユースケース:**

    *   処理前に配列オプションの値をクリアする。

    *   特定のオプションが指定されたときに、他のデフォルト値を動的に変更する。

    *   状態の初期化。

*   **例: 配列オプションの事前クリア**

    ```bash
    declare -A OPTS=(
        [append-list|a@ # リストに追加（毎回クリア可能） ]=()
    )

    clear_append_list() {
        echo "コールバック (--before): append_list (${append_list[*]}) をクリアします"
        append_list=() # グローバル変数を直接操作
    }
    # append-list オプションが解析される直前に clear_append_list を呼び出す
    getoptlong callback --before append-list clear_append_list

    getoptlong init OPTS
    # 例: ./myscript.sh --append-list x --append-list y
    # clear_append_list は2回呼び出され、最終的に append_list には "y" のみが含まれる。
    # --before がなければ、"x" "y" が含まれることになる。
    getoptlong parse "$@" && eval "$(getoptlong set)"

    echo "最終的な append_list: ${append_list[*]}"
    ```

#### 5.1.3. コールバック関数でのエラーハンドリング

コールバック関数内でエラーが発生した場合、その関数自身がエラーを処理する責任があります。通常、これには標準エラーにエラーメッセージを出力し、スクリプトを非ゼロステータスで `exit` するかどうかを決定することが含まれます。

`getoptlong.sh` の主要なエラーハンドリング（`EXIT_ON_ERROR` など）は、`getoptlong.sh` 自体が検出した解析エラー（未定義オプション、必須引数の欠落など）に適用されます。ユーザー定義のコールバック関数からのエラーや非ゼロの終了ステータスを自動的に捕捉することはありません。したがって、コールバックがエラー時にスクリプトを停止させる必要がある場合は、明示的に `exit` を呼び出すべきです。

#### 5.1.4. コールバックを使用したカスタムバリデーション

オプション定義のバリデーション機能（`=i`, `=f`, `=(regex)`）では処理できない複雑なバリデーションは、コールバック関数を使用して実装できます。通常、通常（後処理）のコールバックが値を受け取り、バリデーションロジックを実行します。

### 5.3. オプションのパススルー

スクリプトが受け取ったオプションの一部を、別の内部または外部コマンドに直接渡したい場合があります。`getoptlong.sh` はこれを実現するための2つの主要な方法を提供します：一般的な引数のパススルーと、特定のオプションの収集です。

#### 5.3.1. 一般的な引数のパススルー (`PERMUTE` と `--` を使用)

この方法は、ある時点以降のすべての引数、またはすべての非オプション引数を別のコマンドに渡したい場合に適しています。

*   **`PERMUTE` と `--` (ダブルダッシュ):**

    *   `PERMUTE` を `getoptlong init OPTS PERMUTE=RESTARGS` のように設定すると、オプションとして解釈されない引数（非オプション引数）が指定された配列（`RESTARGS`）に順序通り格納されます。

    *   コマンドライン引数に `--`（ダブルダッシュ）が現れると、それ以降のすべての引数はオプションとして解釈されず、`PERMUTE` で指定された配列（またはデフォルトの `GOL_ARGV`）に直接格納されます。これは、後続のコマンドにオプションを渡す標準的な方法です。

*   **未定義オプションの扱い:**

    *   デフォルトでは、`OPTS` 配列で定義されていないオプションが渡されると、エラーになります（`EXIT_ON_ERROR=1` の場合）。

    *   `EXIT_ON_ERROR=0` を設定し、`getoptlong parse` の戻り値をチェックすることで、未定義オプションを含む引数リストを処理できます。`getoptlong.sh` には「未定義オプションを無視して特定の配列に収集する」という直接的な機能はありません。この場合、`PERMUTE` と `--` を使用するか、引数リストを自分で前処理する必要があります。

*   **パススルーの実現方法（一般的なアプローチ）:**

    1.  **`--` を使用する:** スクリプトのユーザーに、下流のコマンドに渡したいオプションの前に `--` を置くよう指示します。

        ```bash
        # ./myscript.sh --my-opt val -- --downstream-opt --another val
        declare -a PassThroughArgs
        getoptlong init OPTS PERMUTE=PassThroughArgs
        getoptlong parse "$@" && eval "$(getoptlong set)"
        # PassThroughArgs には "--downstream-opt" "--another" "val" が含まれる (PERMUTE使用時)
        # other_command "${PassThroughArgs[@]}"
        ```

    2.  **ラッパースクリプトとしての使用と手動分割:** スクリプトが特定のコマンドのラッパーである場合、自身のオプションを処理した後、残りの引数または変換した引数をそのコマンドに渡します。明示的な分離のために `--` を使用するのが堅牢です。（コード例は簡潔さのため省略）

#### 5.3.2. 特定のオプションの収集 (オプション定義で `>` を使用)

この方法では、特定のオプションを、その値と共に指定された配列に解析中に収集することができます。これは、後で処理するため、または別の関数やコマンドに選択的に渡すために、特定のオプションを収集したい場合に便利です。

この機能を使用するには、オプション定義の型指定子に大なり記号（`>`）を追加します。

*   **基本的な使い方:**

    オプションが末尾に `>` を付けて定義されると、オプション自体（例：`--option-name` や `-o`）とその値（もしあれば）が、指定された配列に連続した要素として追加されます。

    ```bash
    declare -A OPTS=(
        [collect-this|c:>my_collection_array # このオプションとその値を収集]=
        [ another-opt|a:>my_collection_array # これも同じ配列に収集]=
        [flag-collect|f:>flag_array          # このフラグを収集]=
    )
    declare -a my_collection_array=()
    declare -a flag_array=()

    getoptlong init OPTS
    # 例: ./myscript.sh --collect-this foo -a bar --flag-collect
    # 解析後:
    # my_collection_array には ("--collect-this" "foo" "-a" "bar") が含まれる
    # flag_array には ("--flag-collect") が含まれる
    ```

*   **格納先配列:**

    *   オプションが収集される配列は、`>`（および `!` や `:` のような他の型指定子）に続く文字列によって決定されます。例えば、`[myopt|m:>destination_array]` では、オプションは `destination_array` に収集されます。
    *   `>` の後に配列名が指定されていない場合（例：`[myopt|m:>]`）、オプションはオプションのロングネームにちなんで名付けられた配列に収集されます（ハイフンはアンダースコアに変換されます。例：`myopt` は `myopt` 配列に、`my-opt` と定義されていれば `my_opt` 配列に収集されます）。

*   **他の型との組み合わせ:** `>` 指定子は、主要な型指定子（`+`, `:`, `?`, `@`, `%`）の*後*に現れなければなりません。コールバック修飾子 `!` と組み合わせることができます。`>` を使用する場合、主要な型指定子を省略することはできません。これは、ロングオプション名の中のハイフンと曖昧になるためです。

    *   正: `[myopt|m:+!>log_array # このオプションをログに記録してから収集する (フラグ型)]`
        `+` (フラグ型) が明示的に指定されています。コールバック `!` が実行され、その後オプションが `log_array` に渡されます。
    *   正: `[param|p:>my_params # パラメータとその必須の値を収集する]` (必須引数のパススルーを意図している場合)。もし `[param|p:my_params]` であれば、`p` の必須引数が `my_params` に格納されることを意味します（標準的な振る舞いで、パススルーではない）。必須引数のパススルーが意図されている場合は `[param|p:>my_params]` とすべきです。
    *   誤: `[myopt|m:>:destination_array]` (余分なコロン)。修正: `[myopt|m:>destination_array]` (デフォルトの型 `+` が暗黙的に示唆されると仮定し、`[myopt|m:+ >destination_array]`)。または、引数を取る場合: `[myopt|m:>destination_array]`。
    *   誤: `[myopt|m:>!:log_array]`。修正 (フラグ型と仮定): `[myopt|m:+!>log_array]`。必須引数を取る場合: `[myopt|m:!>log_array]`。`!` (コールバック) と `>` (パススルー) は主要な型に対する修飾子です。

    `!` と主要な型との組み合わせを明確にしましょう:
    *   `[cbpassthrough|c:+!>COLLECT_ARRAY]`
        - `+`: フラグ型。
        - `!`: コールバックがトリガーされる。
        - `>COLLECT_ARRAY`: オプション名 (`--cbpassthrough` または `-c`) が `COLLECT_ARRAY` に渡される。
    *   `[argcbpass|a:!>COLLECT_ARRAY]`
        - `:`: 必須引数。
        - `!`: コールバックがトリガーされる（オプション名と値を受け取る）。
        - `>COLLECT_ARRAY`: オプション名とその値が `COLLECT_ARRAY` に渡される。

*   **ヘルプメッセージ:** `>` パススルー指定子で定義されたオプションは、ヘルプメッセージで通常「passthrough to ARRAY_NAME」のように説明されます。ここで `ARRAY_NAME` は収集配列の名前（大文字）です。

この特定のオプション収集は、スクリプトの主要なロジックでは直接使用されないかもしれないが、プロセスの他の部分やサブコマンドに渡すために重要な引数を集める柔軟な方法を提供します。

### 5.4. 実行時の設定変更 (`getoptlong configure`)

`getoptlong init` で設定された一部のパラメータは、後で `getoptlong configure` コマンドを使用して変更できます。

*   **コマンド:** `getoptlong configure <CONFIG_PARAM=VALUE> ...`

*   **例:**

    ```bash
    getoptlong init OPTS EXIT_ON_ERROR=1
    # ... 何らかの処理 ...
    # 一時的にエラーでの終了を抑制
    getoptlong configure EXIT_ON_ERROR=0
    # 次の parse はエラーで終了しない（成功したか戻り値を確認）
    if ! getoptlong parse "${some_args[@]}"; then
        echo "警告: some_args の解析に失敗しましたが、スクリプトは続行します。" >&2
    fi
    # 元に戻す
    getoptlong configure EXIT_ON_ERROR=1
    ```

*   **注意:** すべてのパラメータが実行時の変更に適しているわけではありません。解析の振る舞いを制御するフラグ（`EXIT_ON_ERROR`, `SILENT`, `DEBUG`, `DELIM`）の変更に使うのが最も安全です。`PREFIX` やオプション定義自体に影響するパラメータは、`init` 後に変更すると期待通りに動作しない可能性があります。

### 5.5. 内部状態のダンプ (`getoptlong dump`)

デバッグ目的で、`getoptlong.sh` が内部で保持しているオプション定義情報や現在の値を検査したい場合があります。`getoptlong dump` コマンドを使用します。

*   **コマンド:**

    *   `getoptlong dump`: 解析されたオプション名、対応するシェル変数名、およびそれらの現在の値を表示します。

    *   `getoptlong dump -a` または `getoptlong dump --all`: すべての内部管理パラメータとより詳細なオプション情報を表示します。

*   **例:**

    ```bash
    declare -A OPTS=([file|f:]=foobar.txt [verbose|v+]=0)
    getoptlong init OPTS
    getoptlong parse --verbose --file new.txt -v

    # 変数 $file と $verbose の状態などを表示
    getoptlong dump >&2
    # 出力例（実際の実装に依存）:
    # file (file) = 'new.txt'
    # verbose (verbose) = '2'

    eval "$(getoptlong set)"
    echo "ファイルは: $file, 冗長レベルは: $verbose"
    ```

*   **ユースケース:**
    *   オプションが正しく解析されているかを確認する。
    *   変数が期待通りに設定されているかをデバッグする。
    *   コールバック関数内で現在のオプションの状態を確認する。

## 6. コマンドリファレンス

このセクションでは、`getoptlong.sh` が提供する主要なコマンド（関数）について説明します。

### 6.1. `getoptlong init <opts_array_name> [CONFIGURATIONS...]`

ライブラリを初期化し、オプション定義と設定をロードします。このコマンドは `getoptlong parse` を呼び出す前に実行する必要があります。

*   **`<opts_array_name>`**: (必須) オプション定義を含むBash連想配列の名前を指定します（例：`OPTS`）。

*   **`[CONFIGURATIONS...]`**: `KEY=VALUE` 形式で指定されるオプションの設定パラメータ。主な設定は以下の通りです:

    *   **`PERMUTE=<array_name>`**: オプションとして解釈されない引数（非オプション引数）を格納するBashの通常配列の名前を指定します。例えば、`PERMUTE=REMAINING_ARGS` とした場合、`myscript --opt arg1 arg2` では `arg1` と `arg2` が `REMAINING_ARGS` 配列に格納されます。指定されないか空文字列が提供された場合、最初の非オプション引数で解析が停止します（`POSIXLY_CORRECT` と同様の振る舞い）。デフォルトは `GOL_ARGV`（内部ライブラリの配列名で、通常ユーザーは意識しません）。

    *   **`PREFIX=<string>`**: `getoptlong set` によって設定される変数名の前に付加されるプレフィックスを指定します。例えば、`PREFIX=MYAPP_` でオプションが `--option` の場合、変数 `$MYAPP_option` が設定されます。デフォルトは空文字列（プレフィックスなし）。

    *   **`HELP=<SPEC>`**: 自動的に追加されるヘルプオプションをカスタマイズします。詳細は「4.1. 自動ヘルプオプション」を参照してください。デフォルト: `help|h#show help`。

    *   **`USAGE=<string>`**: ヘルプメッセージの使い方の文字列を指定します。詳細は「4.3.1. Synopsis（使い方）のカスタマイズ（`USAGE` 設定）」を参照してください。設定されていない場合、`getoptlong help` が引数付きで呼び出されない限り、通常は使い方は表示されません。

    *   **`EXIT_ON_ERROR=<BOOL>`**: 解析エラー時にスクリプトを終了するかどうか（`1`で終了、`0`で終了しない）。デフォルトは `1`（終了）。`0` の場合、エラーを検出するために `getoptlong parse` の戻り値をチェックする必要があります。

    *   **`DELIM=<string>`**: 配列 (`@`) またはハッシュ (`%`) オプションで、単一の引数文字列内の複数の値やペアを区切るために使用される文字セットを指定します。デフォルトはスペース、タブ、カンマ（BashのIFSと同様の振る舞い）。例えば、`DELIM=,:` はカンマとコロンで区切ります。

    *   **`SILENT=<BOOL>`**: エラーメッセージを抑制するかどうか（`1`で抑制、`0`で表示）。デフォルトは `0`（表示）。

    *   **`DEBUG=<BOOL>`**: デバッグメッセージを有効にするかどうか（`1`で有効、`0`で無効）。デフォルトは `0`（無効）。

### 6.2. `getoptlong parse "$@"`

定義されたオプションに従ってコマンドライン引数を解析します。

*   **`"$@"`**: (必須) スクリプトに渡されたすべての引数を、受け取ったそのまま渡します。ダブルクォートで囲むことが重要です。

*   **戻り値**:

    *   解析が成功すると終了コード `0` を返します。
    *   解析に失敗した場合（未定義オプション、必須引数の欠落など）、非ゼロの終了コードを返します。
    *   `EXIT_ON_ERROR=1`（デフォルト）の場合、このコマンドは解析エラー時にスクリプトを終了させるため、通常は戻り値のチェックは不要です。
    *   `EXIT_ON_ERROR=0` の場合、エラーを処理するためにこのコマンドの戻り値をチェックする必要があります。

### 6.3. `getoptlong set`

解析されたオプション値に基づいて対応するシェル変数を設定するための一連の `eval` 可能なシェルコマンド文字列を標準出力に生成します。

*   通常は `eval "$(getoptlong set)"` として使用されます。これにより、現在のシェル環境でオプションに対応する変数が設定されます（例：`--file /tmp/f` → `file="/tmp/f"`）。

### 6.4. `getoptlong callback [-b|--before] <opt_name> [callback_function] ...`

指定されたオプションのコールバック関数を登録するか、既に登録されているコールバックの設定を変更します。

*   **`-b` または `--before`**:

    このフラグが指定された場合、コールバック関数はオプションの値が内部的に設定される**前**に呼び出されます。オプションの値は前処理コールバックには渡されません。詳細は「5.1.2. 前処理コールバック」を参照してください。

*   **`<opt_name>`**: (必須) コールバックを登録するオプションのロングネームを指定します（例：`my-option`）。

*   **`[callback_function]`**:

    呼び出すシェル関数の名前。省略された場合、または `-` が指定された場合、`<opt_name>` から関数名が自動的に生成され（ハイフン `-` はアンダースコア `_` に変換、例：`my_option`）、デフォルトのコールバック関数名になります。オプション定義で `!` 接尾辞が使用された場合、コールバックはこのデフォルト名で自動的に登録されます。

*   **`[...]`**: (任意) コールバック関数に渡される追加の固定引数。これらの引数は、コールバック関数が呼び出される際に、オプション名とオプション値（通常のコールバックの場合）の後に渡されます。

### 6.5. `getoptlong configure <CONFIG_PARAM=VALUE> ...`

解析中または他の時点で、グローバル設定パラメータの値（`getoptlong init` で設定）を動的に変更します。

*   **`<CONFIG_PARAM=VALUE>`**: (必須) `getoptlong init` で利用可能な設定パラメータとその新しい値を指定します（例：`EXIT_ON_ERROR=0`）。

*   **注意**: すべてのパラメータが実行時の変更に適しているわけではありません。解析の振る舞いを制御するフラグ（`EXIT_ON_ERROR`, `SILENT`, `DEBUG`, `DELIM`）を変更するのが最も安全です。`PREFIX` やオプション定義自体に関連するパラメータは、`init` 後に変更すると期待通りに動作しない可能性があります。

### 6.6. `getoptlong dump [-a|--all]`

`getoptlong.sh` の内部状態（オプション定義、現在の値、設定など）を標準エラー出力にダンプ（表示）します。主にデバッグに使用されます。

*   **`-a` または `--all`**: 指定された場合、より詳細な内部情報（管理パラメータを含む）を表示します。指定されない場合、主に解析されたオプション名、対応するシェル変数名、および現在の値を表示します。

### 6.7. `getoptlong help [SYNOPSIS]`

現在のオプション定義と設定に基づいて、生成されたヘルプメッセージを手動で表示します。オプションの `SYNOPSIS` 引数がどのように扱われるかなど、その振る舞いの詳細については、「4.3.2. `getoptlong help` による手動表示」を参照してください。

このコマンドは、自動ヘルプオプション（例：`--help`）が呼び出されたときにも内部的に実行されます。

## 7. 実用的な例

これまでのセクションでは、`getoptlong.sh` の個々の機能を説明してきました。このセクションでは、いくつかの実用的な例と、より複雑なシナリオでの使用法を示します。また、より具体的なユースケースや高度なテクニックについては、`ex/` ディレクトリのサンプルスクリプトを参照してください。

### 7.1. 必須オプションとオプション引数の組み合わせ

```bash
#!/usr/bin/env bash

# getoptlong.sh がPATHまたはカレントディレクトリにあると仮定
if ! . getoptlong.sh; then echo "エラー: getoptlong.sh が見つかりません。" >&2; exit 1; fi

# オプション定義
declare -A OPTS=(
    [input|i:    # 入力ファイルを指定（必須） ]=
    [output|o:   # 出力ファイルを指定（必須） ]=
    [format|f?   # 出力フォーマット（任意、指定する場合は値が必要） ]= # 値なしでの使用は非推奨
    [compress|c  # 出力を圧縮（フラグ） ]=
    [level|l:=i  # 圧縮レベル（整数、compress使用時のみ） ]=1
    [verbose|v+  # 冗長レベル ]=0
    [&USAGE]="Usage: $(basename "$0") -i <input> -o <output> [-f <format>] [-c [-l <level>]] [-v]"
    [&HELP]="process-data|H#データ処理スクリプトのヘルプ"
)

# コールバック関数（例：指定されたフォーマットを大文字にする）
# format オプションに '!' がないので、getoptlong callback で登録
format_callback() {
    local opt_name="$1"
    local val="$2"
    if [[ -n "$val" ]]; then
        format="${val^^}" # グローバル変数 'format' を直接変更
        (( verbose > 0 )) && echo "デバッグ: フォーマットがコールバック経由で '$format' に設定されました。" >&2
    else
        echo "警告: format オプションが値なしで使用されました。" >&2
    fi
}
getoptlong callback format format_callback

# getoptlong の初期化
getoptlong init OPTS

# 引数の解析
if ! getoptlong parse "$@"; then
    exit 1
fi
eval "$(getoptlong set)"

# 必須オプションのチェック
if [[ -z "$input" ]] || [[ -z "$output" ]]; then
    echo "エラー: 入力ファイル (-i) と出力ファイル (-o) は必須です。" >&2
    getoptlong help # エラー時にヘルプを表示
    exit 1
fi

# メイン処理
echo "入力ファイル: $input"
echo "出力ファイル: $output"

if [[ -v format ]]; then # format オプションが使用された場合（値ありまたは空文字列）
    if [[ -n "$format" ]]; then
        echo "出力フォーマット: $format"
    else
        echo "出力フォーマット: (指定なし)" # --format のみのケース
    fi
fi

if [[ -n "$compress" ]]; then
    echo "圧縮: 有効 (レベル: $level)"
    # 圧縮処理...
else
    echo "圧縮: 無効"
fi

echo "冗長レベル: $verbose"

# ...実際の処理...
echo "処理が完了しました。"
```

**この例のキーポイント:**

*   必須オプション（`input`, `output`）のチェック。

*   オプション引数（`format`）の処理とコールバックによる値の加工。

*   フラグオプション（`compress`）とそれに関連する別のオプション（`level`）の組み合わせ。

*   `&USAGE` と `&HELP` を使用したヘルプメッセージのカスタマイズ。

### 7.2. サブコマンドを持つスクリプト（簡易版）

`getoptlong.sh` は `init` と `parse` を複数回呼び出すことができます。これは、サブコマンドごとに異なるオプションセットを定義して処理するために使用できます。

```bash
#!/bin/bash
if ! . getoptlong.sh; then echo "エラー: getoptlong.sh が見つかりません。" >&2; exit 1; fi

# グローバルオプション
declare -A GlobalOPTS=(
    [verbose|v+ # 詳細出力 ]=0
    [help|h     # ヘルプを表示 ]=
)
getoptlong init GlobalOPTS
declare -a RemainingArgs
# グローバルオプションのみを解析。エラーで終了せず、残りを RemainingArgs に格納。
getoptlong configure EXIT_ON_ERROR=0 PERMUTE=RemainingArgs
getoptlong parse "$@"
eval "$(getoptlong set)" # グローバルオプションの変数を設定

# グローバルヘルプが要求されたか、サブコマンドがない場合は全体のヘルプを表示
if [[ -n "$help" ]] || (( ${#RemainingArgs[@]} == 0 )); then
    echo "Usage: $(basename "$0") [global_options] <subcommand> [subcommand_options]"
    echo ""
    echo "Global Options:"
    getoptlong help # GlobalOPTS のヘルプ
    echo ""
    echo "Subcommands:"
    echo "  commit    リポジトリに変更を記録する"
    echo "  push      リモート参照を関連オブジェクトと共に更新する"
    exit 0
fi

subcommand="${RemainingArgs[0]}"
# サブコマンドの引数は RemainingArgs からサブコマンド自体を除いたもの
SubcommandArgs=("${RemainingArgs[@]:1}")

case "$subcommand" in
    commit)
        declare -A CommitOPTS=(
            [message|m: # コミットメッセージ ]=
            [all|a      # すべての変更をステージング ]=
            [help|h     # commit サブコマンドのヘルプ ]= # サブコマンドごとのヘルプ
        )
        getoptlong init CommitOPTS # 新しいオプションセットで再初期化
        # サブコマンドの引数のみを解析
        if ! getoptlong parse "${SubcommandArgs[@]}"; then exit 1; fi
        eval "$(getoptlong set)" # commit 用の変数を設定

        if [[ -n "$help" ]]; then # サブコマンドのヘルプ
             getoptlong help "Usage: $(basename "$0") commit [options]"
             exit 0
        fi

        echo "サブコマンド: commit"
        [[ -n "$message" ]] && echo "  メッセージ: $message"
        [[ -n "$all" ]] && echo "  All:有効"
        (( verbose > 0 )) && echo "  Verbose (global): $verbose"
        # 例: git commit を実行
        ;;
    push)
        declare -A PushOPTS=(
            [remote|r:  # リモートリポジトリ ]=origin
            [force|f   # 強制プッシュ       ]=
            [help|h    # push サブコマンドのヘルプ ]=
        )
        getoptlong init PushOPTS
        if ! getoptlong parse "${SubcommandArgs[@]}"; then exit 1; fi
        eval "$(getoptlong set)"

        if [[ -n "$help" ]]; then
             getoptlong help "Usage: $(basename "$0") push [options]"
             exit 0
        fi

        echo "サブコマンド: push"
        echo "  リモート: ${remote}"
        [[ -n "$force" ]] && echo "  Force: 有効"
        (( verbose > 0 )) && echo "  Verbose (global): $verbose"
        # 例: git push を実行
        ;;
    *)
        echo "エラー: 不明なサブコマンド '$subcommand'" >&2
        getoptlong init GlobalOPTS # ヘルプ表示のために GlobalOPTS に戻す
        getoptlong help "Usage: $(basename "$0") [global_options] <subcommand> [subcommand_options]"
        exit 1
        ;;
esac
```

**この例のキーポイント:**

*   グローバルオプションとサブコマンド固有オプションの分離。

*   `getoptlong init` と `parse` の複数回呼び出し。

*   `PERMUTE` を使用したサブコマンドとその引数の分離。

*   サブコマンドごとのヘルプ表示への配慮（各OPTSに `help|h` を定義）。

*   **注意:** この例は基本的な考え方を示しています。実際のサブコマンド処理は、より多くのエッジケースとエラーハンドリングを考慮する必要があります。より詳細な例は `ex/subcmd.sh` にあります。

### 7.3. `ex/` ディレクトリのサンプルスクリプト

`getoptlong.sh` リポジトリには、さまざまな機能を示すサンプルスクリプトが `ex/` ディレクトリに含まれています。これらは、より具体的なユースケースや高度なテクニックを学ぶのに役立ちます。

*   **`ex/repeat.sh`**: 様々なオプションタイプ（配列、ハッシュ、インクリメンタルフラグなど）の基本的な使い方を示します。

*   **`ex/prefix.sh`**: `PREFIX` 設定の使用例。

*   **`ex/cmap`**: 色付けマッパー。複雑なオプション解析、コールバック、データ処理の良い例。

*   **`ex/cmap-prefix`**: `PREFIX` を適用した `cmap` の例。

*   **`ex/md`**: サンプルのMarkdownパーサー。

*   **`ex/silent.sh`**: `SILENT` 設定の使用例。

*   **`ex/subcmd.sh`**: グローバルオプションとローカルオプションの処理、共有ヘルプなどを含む、サブコマンドを持つスクリプトのより洗練された例。

これらのサンプルを実行し、そのコードを読むことをお勧めします。

## 8. 設定キー

オプション定義配列（`OPTS`）内で、`&KEY=VALUE` 形式の特別なキーを使用して、通常のオプション定義とは別に `getoptlong.sh` の振る舞いを設定できます。これらの設定は、`getoptlong init` コマンドの引数として指定された同じ名前の設定よりも優先されます。

*   **`&HELP=<SPEC>`**

    *   説明: 自動生成されるヘルプオプションの定義をカスタマイズします。`getoptlong init` の `HELP` パラメータを上書きします。詳細は「4.1. 自動ヘルプオプション」を参照してください。

    *   例: `[&HELP]="show-usage|u#使い方ガイド"`

    *   デフォルト: `help|h#show help`

*   **`&USAGE=<string>`**

    *   説明: ヘルプメッセージの冒頭に表示される使い方（Synopsis）の文字列を指定します。`getoptlong init` の `USAGE` パラメータを上書きします。詳細は「4.3.1. Synopsis（使い方）のカスタマイズ（`USAGE` 設定）」を参照してください。

    *   例: `[&USAGE]="Usage: $(basename "$0") [OPTIONS] SOURCE DEST"`

    *   デフォルト: 指定なし（`getoptlong help` に引数が渡されない限り、Synopsisは表示されません）。

*   **その他の設定キー:**

    *   現在のドキュメントでは、他の `&KEY` 形式の設定については明示的に言及されていませんが、ライブラリのバージョンによっては、他の設定（例：`&DELIM`, `&PREFIX`）がサポートされている可能性があります。正確な情報については、使用している `getoptlong.sh` のバージョンのドキュメントまたはソースコードを確認してください。

## 9. 関連項目

`getoptlong.sh` と同様の目的を持つ他のツール、および関連リソース:

-   **GNU `getopt`**: Cライブラリの `getopt_long` 関数のコマンドラインユーティリティ版。複雑なオプションの解析に使用されますが、シェルスクリプトでの使用には余分な手間がかかる場合があります。
-   **Bash `getopts`**: Bashの組み込みコマンド。POSIXスタイルのショートオプションのみをサポートし、ロングオプションやオプションの自由な順序付け（順列）は処理しません。
-   **Perl `Getopt::Long`**: Perlで広く使用されているコマンドラインオプション解析モジュール。`getoptlong.sh` はいくつかの側面でこのモジュールの影響を受けています。
-   **Python `argparse`**: コマンドライン引数を解析するための標準的なPythonライブラリモジュールで、その強力さと柔軟性で知られています。
-   [`getoptions` (ko1nksm/getoptions)](https://github.com/ko1nksm/getoptions): `getoptlong.sh` のいくつかの機能に影響を与えた、シェルスクリプト用の別の強力なオプションパーサー。
-   [`argh` (adrienverge/argh)](https://github.com/adrienverge/argh): bash用のミニマリストな引数ハンドラ。
